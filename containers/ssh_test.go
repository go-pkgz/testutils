package containers

import (
	"context"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSSHTestContainer(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping SSH container test in short mode")
	}

	ctx := context.Background()

	t.Run("create and cleanup container", func(t *testing.T) {
		ssh := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		assert.NotEmpty(t, ssh.Host)
		assert.NotEmpty(t, ssh.Port)
		assert.Equal(t, "test", ssh.User)
	})

	t.Run("custom user container", func(t *testing.T) {
		ssh := NewSSHTestContainerWithUser(ctx, t, "custom")
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		assert.NotEmpty(t, ssh.Host)
		assert.NotEmpty(t, ssh.Port)
		assert.Equal(t, "custom", ssh.User)
	})

	t.Run("container is accessible", func(t *testing.T) {
		ssh := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		// use ssh-keyscan to verify the host is accessible
		// values come from the test container itself, so this is not vulnerable to command injection
		// ssh.Port and ssh.Host are generated by the test container and are not user input
		cmd := exec.Command("ssh-keyscan", "-p", ssh.Port.Port(), ssh.Host) // #nosec G204 -- these params are from our test container
		out, err := cmd.CombinedOutput()
		require.NoError(t, err)
		t.Logf("ssh-keyscan output: %s", out)
		assert.Contains(t, string(out), "ssh-", "should return ssh key")
	})

	t.Run("multiple containers", func(t *testing.T) {
		ssh1 := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh1.Close(ctx)) }()

		ssh2 := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh2.Close(ctx)) }()

		assert.NotEqual(t, ssh1.Port, ssh2.Port)
		assert.NotEqual(t, ssh1.Address(), ssh2.Address())
	})

	t.Run("file operations", func(t *testing.T) {
		ssh := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		// create a temporary directory for test files
		tempDir := t.TempDir()

		// create a test file
		testFile := filepath.Join(tempDir, "test-file.txt")
		testContent := "Hello SFTP world!"
		require.NoError(t, os.WriteFile(testFile, []byte(testContent), 0o600))

		// test SaveFile - upload file to container
		remotePath := "/tmp/test-file.txt"
		err := ssh.SaveFile(ctx, testFile, remotePath)
		require.NoError(t, err, "Failed to upload file to SSH container")

		// test ListFiles - check if file exists
		files, err := ssh.ListFiles(ctx, "/tmp")
		require.NoError(t, err, "Failed to list files in SSH container")

		found := false
		for _, file := range files {
			if file.Name() == "test-file.txt" {
				found = true
				break
			}
		}
		require.True(t, found, "Uploaded file not found in SSH container")

		// test GetFile - download file from container
		downloadedFile := filepath.Join(tempDir, "downloaded-file.txt")
		err = ssh.GetFile(ctx, remotePath, downloadedFile)
		require.NoError(t, err, "Failed to download file from SSH container")

		// verify content
		content, err := os.ReadFile(downloadedFile) // #nosec G304 -- Safe file access, path is controlled in test
		require.NoError(t, err)
		assert.Equal(t, testContent, string(content), "Downloaded content doesn't match original")

		// test DeleteFile - delete file from container
		err = ssh.DeleteFile(ctx, remotePath)
		require.NoError(t, err, "Failed to delete file from SSH container")

		// verify file was deleted
		files, err = ssh.ListFiles(ctx, "/tmp")
		require.NoError(t, err)

		found = false
		for _, file := range files {
			if file.Name() == "test-file.txt" {
				found = true
				break
			}
		}
		require.False(t, found, "File should have been deleted from SSH container")

		// test with nested directories
		nestedPath := "/tmp/nested/directory/test-nested.txt"
		err = ssh.SaveFile(ctx, testFile, nestedPath)
		require.NoError(t, err, "Failed to upload file to nested directory")

		// list the nested directory
		files, err = ssh.ListFiles(ctx, "/tmp/nested/directory")
		require.NoError(t, err)

		found = false
		for _, file := range files {
			if file.Name() == "test-nested.txt" {
				found = true
				break
			}
		}
		require.True(t, found, "File should exist in nested directory")

		// delete the nested file
		err = ssh.DeleteFile(ctx, nestedPath)
		require.NoError(t, err)

		// verify nested file was deleted
		files, err = ssh.ListFiles(ctx, "/tmp/nested/directory")
		require.NoError(t, err)

		found = false
		for _, file := range files {
			if file.Name() == "test-nested.txt" {
				found = true
				break
			}
		}
		require.False(t, found, "Nested file should have been deleted")
	})

	t.Run("file operations with relative paths", func(t *testing.T) {
		ssh := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		// create a temporary directory for test files
		tempDir := t.TempDir()

		// create a test file
		testFile := filepath.Join(tempDir, "test-relative.txt")
		testContent := "Testing relative paths!"
		require.NoError(t, os.WriteFile(testFile, []byte(testContent), 0o600))

		// test SaveFile with relative path (should save to user's home directory)
		relativePath := "subdir/test-relative.txt"
		err := ssh.SaveFile(ctx, testFile, relativePath)
		require.NoError(t, err, "Failed to upload file with relative path")

		// verify file exists by getting it back
		downloadedFile := filepath.Join(tempDir, "downloaded-relative.txt")
		err = ssh.GetFile(ctx, relativePath, downloadedFile)
		require.NoError(t, err, "Failed to download file from relative path")

		// verify content
		content, err := os.ReadFile(downloadedFile) // #nosec G304 -- Safe file access, path is controlled in test
		require.NoError(t, err)
		assert.Equal(t, testContent, string(content), "Downloaded content doesn't match original")

		// test with multiple levels of subdirectories
		deepRelativePath := "deep/nested/subdir/test-deep.txt"
		err = ssh.SaveFile(ctx, testFile, deepRelativePath)
		require.NoError(t, err, "Failed to upload file to deep nested relative path")

		// clean up
		err = ssh.DeleteFile(ctx, relativePath)
		require.NoError(t, err)
		err = ssh.DeleteFile(ctx, deepRelativePath)
		require.NoError(t, err)
	})

	t.Run("file operations security checks", func(t *testing.T) {
		ssh := NewSSHTestContainer(ctx, t)
		defer func() { require.NoError(t, ssh.Close(ctx)) }()

		// create a temporary directory for test files
		tempDir := t.TempDir()

		// create a test file
		testFile := filepath.Join(tempDir, "test-security.txt")
		require.NoError(t, os.WriteFile(testFile, []byte("security test"), 0o600))

		// test path traversal attempts - should fail
		traversalPaths := []string{
			"../../../etc/passwd",
			"test/../../../etc/passwd",
			"test/../../../../../../tmp/evil",
			"test\x00/evil", // null byte injection
		}

		for _, badPath := range traversalPaths {
			err := ssh.SaveFile(ctx, testFile, badPath)
			require.Error(t, err, "Should reject path traversal attempt: %s", badPath)
			assert.Contains(t, err.Error(), "invalid path component", "Error should mention invalid path component for: %s", badPath)
		}

		// test valid paths with dots - should succeed
		validPaths := []string{
			"test.file.txt",
			"test-dir.d/file.txt",
			"./file.txt", // current directory reference
		}

		for _, validPath := range validPaths {
			err := ssh.SaveFile(ctx, testFile, validPath)
			require.NoError(t, err, "Should accept valid path: %s", validPath)

			// clean up
			err = ssh.DeleteFile(ctx, validPath)
			require.NoError(t, err)
		}
	})
}
